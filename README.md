# TankWar

项目目的：通过该项目建立面向对象设计思维，并复习OO、容器、网络、线程等基础知识。

## Part 1：项目初步

项目流程:

1.建立新项目

2.创建一个窗口

3.显示这个窗口

4.画出一个方块

- 谁初始化了Graphics g这个参数

5.移动这个方块

- 自动化: repaint --> paint
- 手动控制：相应键盘事件(**观察者模式**)
  - Frame.addKeyListener()

6.为什么使用内部类？

- 不需要让别的类访问键盘监听类
- 高内聚 低耦合

7.为什么不使用方法的内部类（局部内部类）？

- 可以用，看起来不方便
- 内部类可以非常方便访问包装类的局部变量

8.为什么继承KeyAdapter而不是直接实现KeyListener?

- 为了只重写自己需要的方法(keyPressed、KeyReleased)，而不是都实现(还有用不到的KeyTyped)

9.最基本的面向对象的设计思想

- 抽象出名词：类、属性
- 抽象出动词：方法

10.为什么Enum比int类型好？

- 编译期间就能知道赋值是不是有问题

11.将坦克换成图片

- 关于classloader的基础知识
- 显示图片，使用ImageIO

12.图片闪烁如何解决？

- 为什么会出现图片闪烁？

  - 显存刷新率很快，数据来不及全部由内存加载到显存中

- 双缓冲：将图片在内存中先画好，确认画好之后再一次性加载到显存中

13.打出一颗子弹

- 按下Ctrl键，主战坦克打出一颗子弹
- 用面向对象思想去考虑：使用单例模式

14.打出一串子弹

- 将子弹放在容器中List<BUllet>

15.做边界检查，当子弹飞出游戏区，应该从List中删掉

- 添加live属性，用于判断子弹是否存活

16.将子弹从坦克中心位置打出

- 根据坦克图片、子弹图片的大小，和左上角的位置计算子弹左上角的位置

17.子弹与敌军坦克的碰撞检测

- 摧毁一辆坦克

18.让敌军坦克动起来

- 在Dir中新增randomDir()方法，Tank类在Move后调用该方法
- 在Tank类中通过random.nextInt()，设定魔法值，开启发子弹功能

19.加入多辆敌军坦克

- 增加一个list，用来存放敌军坦克

20.加入爆炸

- 增加爆炸gif图片
- 新增Expolde类，利用step标志变量实现

21.加入声音

- 通过增加线程来播放声音

## Part 2：项目进阶

1.增加配置文件让程序更灵活

- 增加PropertyMgr类，读取txt配置文件内容

2.用**策略模式**让子弹发射更灵活

- 切换主战坦克的发射模式
  - default：发一颗子弹
  - FourDir：向四个方向同时发射子弹
  - LeftRight：左右两个方向
  - LeftUp：上下两个方向

3.考虑加入一堵墙、一枚地雷、一座机枪塔

- 添加新的游戏物体的时候，让TankFrame表现得比较优雅
  - 对修改关闭，对拓展开放
- 碰撞如何考虑？（**责任链模式**）
  - 新加进来的游戏物体，如何做无缝结合的碰撞检测
  - 不需要修改原来的代码

4.Model和View分离（MVC）

- Model：内容		View：展现形式

5.坦克 Model View

- GameModel
- Facade（**门面模式**）通过门面与多个内部物体打交道
- Mediator（**调停者模式**）内部多个物体只与调停者打交道

6.存盘功能（序列化）

- Serializable接口

7.线程

- 复习与补充（线程的三种实现方式）

## Part 3 网络版（Netty）

1.写一个基于netty的聊天室

- client UI不重要
- server上的客户端通道需要保存
- netty中的ByteBuf不是位于JVM内部而是在操作系统上的，因此无法被JVM垃圾回收，采用引用计数法（Reference Count）由netty进行垃圾回收。可以用buf.refcnt()拿到引用数。

2.server关闭流程

- 通知客户端，我要准备关闭，你要准备好
- 拒绝新的连接
- 等几分钟，看到的客户端处理完成
- 开始关闭流程，迭代发送关闭信息，客户端收到关闭信息进行自动处理（服务器连接已经断开）
- 确认所有客户端断开
- server保存现有的工作数据
- 停止线程组
- 退出

3.Encoder Decoder（一个消息如何从client到server）

- 把消息转为字符串数组：Encoder
- 把字符串数组转为消息：Decoder
- 方式一："30,20".getBytes()
- 方式二：30：[0101 .. 1001] 20：[1010 ... 1010] 8 bytes send to server
- 第二种方式更好。原因：字符串长度不固定，编码不固定，语言不固定，转字符串效率比较低，内存copy不用转，直接copy
- 编码器与解码器由Netty自动识别调用，不用担心在需要Encoder时会误用Deoder，也不用担心在需要Decoder时会误用。
- Encoder多种不同的编解码器可以混在一起使用，共同实现程序的业务逻辑

4.Embedded Channel进行单元测试

- Encoder: 往**外**写（writeOutbound），然后读（readOutbound）
- Decoder: 往**里**写（writeInbound），然后读（readInbound）